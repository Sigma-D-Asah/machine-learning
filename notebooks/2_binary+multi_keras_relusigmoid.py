# -*- coding: utf-8 -*-
"""2_Binary+Multi_Keras_ReluSigmoid.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AoOkURgrpg_g_xyKqFTnKZOzl4vLT_D9

### 0. Import Library and Upload Files

Note: Update now splitting the models in two
"""

import pandas as pd
import numpy as np
import seaborn as sns
import joblib
import matplotlib.pyplot as plt

from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from yellowbrick.cluster import KElbowVisualizer

from google.colab import drive, files
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from tensorflow.keras import layers, Model

files.upload()

# Changed to new labels
dfraw = pd.read_csv('predictive_maintenance_new.csv')
dfraw.head()

df = dfraw.drop(['id', 'product_id'], axis=1)
df.head()

"""# 1 Praproses Data"""

df.describe()

# Mengecek dataset menggunakan isnull().sum()
df.isnull().sum()

# Mengecek dataset menggunakan duplicated().sum()
df.duplicated().sum()

cat = df.select_dtypes(include=['object']).columns.tolist()
for col in cat:
    le = LabelEncoder()
    df[col] = le.fit_transform(df[col])
df.head()

df.columns.tolist()

X = df.drop(['target', 'failure_type'], axis=1)
yb = df[['target']]
yc = df[['failure_type']]

X_train, X_test, yb_train, yb_test, yc_train, yc_test = train_test_split(
    X,
    yb,
    yc,
    test_size=0.3,
    random_state=42
)
mm = MinMaxScaler(feature_range=(0, 1))
num_cols = X_train.select_dtypes(include=['int64', 'float64']).columns
X_train[num_cols] = mm.fit_transform(X_train[num_cols])
X_test[num_cols] = mm.transform(X_test[num_cols])

"""Target 1: ReLu Binary"""

inputs = layers.Input(shape=(X_train.shape[1],))
x = layers.Dense(64, activation='relu')(inputs)
x = layers.Dense(32, activation='relu')(x)
output_binary = layers.Dense(1, activation='sigmoid')(x)

model_binary = Model(inputs, output_binary)

model_binary.compile(
    optimizer='adam',
    loss='binary_crossentropy',
    metrics=['accuracy']
)

model_binary.summary()

history_binary = model_binary.fit(
    X_train,
    yb_train,
    validation_split=0.2,
    epochs=20,
    batch_size=32
)

yb_pred = model_binary.predict(X_test)
yb_pred = (yb_pred > 0.5).astype(int)

from sklearn.metrics import confusion_matrix, classification_report
import seaborn as sns
import matplotlib.pyplot as plt

cm_bin = confusion_matrix(yb_test, yb_pred)

sns.heatmap(cm_bin, annot=True, fmt="d")
plt.title("Confusion Matrix – Binary Target")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

print(classification_report(yb_test, yb_pred))

"""Target 2: Sigmoid Multiclass Failure Type"""

num_classes = len(le.classes_)

inputs2 = layers.Input(shape=(X_train.shape[1],))
m = layers.Dense(64, activation='relu')(inputs2)
m = layers.Dense(32, activation='relu')(m)
output_multi = layers.Dense(num_classes, activation='softmax')(m)

model_multi = Model(inputs2, output_multi)

model_multi.compile(
    optimizer='adam',
    loss='sparse_categorical_crossentropy',
    metrics=['accuracy']
)

model_multi.summary()

history_multi = model_multi.fit(
    X_train,
    yc_train,
    validation_split=0.2,
    epochs=20,
    batch_size=32
)

yc_pred = model_multi.predict(X_test)
yc_pred = np.argmax(yc_pred, axis=1)

print(classification_report(yc_test, yc_pred))

yc_test = yc_test.astype(int)
yc_pred = yc_pred.astype(int)

cm_multi = confusion_matrix(yc_test, yc_pred)

sns.heatmap(cm_multi, annot=True, fmt="d")
plt.title("Confusion Matrix – Failure Type")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

"""Saving Model"""

model_binary.save("binaryfailure.keras")
model_multi.save("multiclassfailtype.keras")

"""Deprecated Model"""

X_train, X_test, y1_train, y1_test = train_test_split(
    X,
    y1,
    test_size=0.3,
    random_state=42
)

# Pisahkan kembali
yb_train = Y_train['Target']
yc_train = Y_train['Failure Type']

yb_test = Y_test['Target']
yc_test = Y_test['Failure Type']

inputs = layers.Input(shape=(X_train.shape[1],))

# shared layers
x = layers.Dense(64, activation='relu')(inputs)
x = layers.Dense(32, activation='relu')(x)

# output 1: binary
out_binary = layers.Dense(1, activation='sigmoid', name='binary_output')(x)

# output 2: multiclass
num_classes = len(le.classes_)
out_multi = layers.Dense(num_classes, activation='softmax', name='multiclass_output')(x)

# model
model = Model(inputs, [out_binary, out_multi])

model.compile(
    optimizer='adam',
    loss={
        'binary_output': 'binary_crossentropy',
        'multiclass_output': 'sparse_categorical_crossentropy'
    },
    metrics={
        'binary_output': 'accuracy',
        'multiclass_output': 'accuracy'
    }
)

model.summary()

history = model.fit(
    X_train,
    {
        'binary_output': yb_train,
        'multiclass_output': yc_train
    },
    validation_split=0.2,
    epochs=20,
    batch_size=32
)

yb_pred, yc_pred = model.predict(X_test)
yb_pred = (yb_pred > 0.5).astype(int)
yc_pred = np.argmax(yc_pred, axis=1)

yb_test = yb_test.astype(int)
yc_test = yc_test.astype(int)

model.evaluate(
    X_test,
    {
        'binary_output': yb_test,
        'multiclass_output': yc_test
    }
)

from sklearn.metrics import confusion_matrix, classification_report
import seaborn as sns
import matplotlib.pyplot as plt

cm_bin = confusion_matrix(yb_test, yb_pred)

plt.figure(figsize=(5,4))
sns.heatmap(cm_bin, annot=True, fmt="d")
plt.title("Confusion Matrix - Binary (Target)")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

print("\nBinary Classification Report:\n")
print(classification_report(yb_test, yb_pred))

cm_multi = confusion_matrix(yc_test, yc_pred)

plt.figure(figsize=(7,6))
sns.heatmap(cm_multi, annot=True, fmt="d")
plt.title("Confusion Matrix - Failure Type (Multiclass)")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

print("\nMulticlass Classification Report:\n")
print(classification_report(yc_test, yc_pred))

import joblib

joblib.dump(model, 'predictive_maintenance.h5')